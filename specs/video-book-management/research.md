# 技術調査・設計方針

## 技術スタック選定

### バックエンド

**Node.js + Express**

- 理由: 非同期処理に優れ、動画/画像処理に適している
- バージョン: Node.js 18.x 以上
- フレームワーク: Express 4.x

### データベース

**SQLite（初期）→ PostgreSQL（本番想定）**

- 理由:
  - SQLite: 開発時の軽量さ、ゼロコンフィグ
  - PostgreSQL: 本番環境での拡張性、JSONB型でのメタデータ管理
- ORM: Prisma（型安全性、マイグレーション管理）

### OCR エンジン

**Tesseract.js**

- 理由:
  - オープンソース、無料
  - 日本語・英語対応
  - Node.js統合が容易
  - オフライン動作可能（将来要件）
- 代替案: Google Cloud Vision API（精度重視の場合）

### 動画処理

**FFmpeg（fluent-ffmpeg ラッパー）**

- 理由:
  - 業界標準の動画処理ツール
  - フレーム抽出、フォーマット変換に対応
  - Node.jsバインディングが成熟

### フロントエンド（今回は最小実装）

**シンプルなHTML + 軽量フレームワーク**

- 初期: 静的HTML + Vanilla JS
- Phase 2以降: React or Vue.js検討

## アーキテクチャ設計

### レイヤー構造

```
┌─────────────────────────────┐
│   Presentation Layer        │  ← Express Routes / API
├─────────────────────────────┤
│   Business Logic Layer      │  ← Services (Video, OCR, Book, Loan)
├─────────────────────────────┤
│   Data Access Layer         │  ← Prisma ORM / Repository Pattern
├─────────────────────────────┤
│   Database                  │  ← SQLite / PostgreSQL
└─────────────────────────────┘
```

### モジュール分割

1. **video-processor**: 動画アップロード、フレーム抽出
2. **ocr-service**: OCR実行、結果整形
3. **book-service**: 書籍CRUD、検索
4. **loan-service**: 貸出管理ロジック
5. **api-routes**: RESTful APIエンドポイント

### ディレクトリ構造

```
src/
├── config/           # 設定ファイル
├── services/         # ビジネスロジック
│   ├── video.service.js
│   ├── ocr.service.js
│   ├── book.service.js
│   └── loan.service.js
├── models/           # Prismaスキーマ
├── routes/           # APIルート
│   ├── video.routes.js
│   ├── book.routes.js
│   └── loan.routes.js
├── middleware/       # Express ミドルウェア
├── utils/            # ユーティリティ関数
└── app.js            # エントリーポイント
```

## パフォーマンス設計

### 動画処理の最適化

- **ストリーミング処理**: 大容量動画もメモリ効率的に処理
- **並列フレーム抽出**: Worker Threadsで複数フレーム同時処理
- **キャッシング**: 処理済みフレームを一時保存

### OCR処理の最適化

- **バッチ処理**: 複数フレームをまとめてOCR実行
- **ROI（関心領域）検出**: 書籍タイトル領域のみを処理
- **信頼度フィルタリング**: 低信頼度結果は早期除外

## エラーハンドリング戦略

### 動画処理エラー

- 非対応フォーマット → 明確なエラーメッセージ
- ファイルサイズ超過 → 500MB制限を事前チェック
- 破損ファイル → FFmpeg エラーをキャッチして通知

### OCR エラー

- 認識失敗 → 信頼度0%で結果返却、手動入力促す
- タイムアウト → 3秒/フレームで打ち切り

### データベースエラー

- 重複登録 → UNIQUE制約でキャッチ、既存データ表示
- トランザクション失敗 → ロールバックとリトライ

## セキュリティ考慮事項

### ファイルアップロード

- MIME typeチェック（video/\* のみ許可）
- ファイル拡張子検証
- ウイルススキャン（将来要件）

### データベース

- パラメータ化クエリ（Prismaで自動対応）
- 入力値のバリデーション（Joi or Zod）

### API

- レート制限（express-rate-limit）
- CORS設定
- 入力サニタイゼーション

## テスト戦略

### 単体テスト（Jest）

- 各サービスクラスの主要メソッド
- ユーティリティ関数
- カバレッジ目標: 70%

### 統合テスト（Supertest）

- APIエンドポイント
- データベース連携

### E2Eテスト（最小限）

- 動画アップロード → OCR → 書籍登録フロー

## 依存関係

### 必須パッケージ

```json
{
  "express": "^4.18.0",
  "prisma": "^5.0.0",
  "@prisma/client": "^5.0.0",
  "fluent-ffmpeg": "^2.1.2",
  "tesseract.js": "^4.0.0",
  "multer": "^1.4.5-lts.1",
  "joi": "^17.9.0"
}
```

### 開発依存関係

```json
{
  "jest": "^29.0.0",
  "supertest": "^6.3.0",
  "eslint": "^8.0.0",
  "prettier": "^3.0.0"
}
```

## リスクと緩和策

### リスク1: OCR精度が目標未達

- **緩和策**:
  - 前処理（画像補正、コントラスト調整）
  - 複数OCRエンジンの併用
  - ユーザー修正UIの充実

### リスク2: 動画処理パフォーマンス

- **緩和策**:
  - 非同期ジョブキュー導入（Bull）
  - 処理状況のプログレス表示
  - フレーム抽出間隔の調整可能化

### リスク3: スケーラビリティ

- **緩和策**:
  - 初期はシンプルな構成で開始
  - 将来的にマイクロサービス化を検討
  - データベース分離、キャッシュ層追加

## 次のステップ

Phase 1でデータモデル、API契約、クイックスタートガイドを作成。
